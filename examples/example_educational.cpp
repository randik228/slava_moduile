#include "matrix_gf2/matrix.hpp"
#include <iostream>

using namespace matrix_gf2;

int main() {
    std::cout << "=== УЧЕБНЫЙ РЕЖИМ: Пошаговое объяснение операций ===\n\n";
    
    // Пример 1: Прямой ход Гаусса с объяснениями
    std::cout << "===================================================\n";
    std::cout << "ПРИМЕР 1: Прямой ход метода Гаусса над GF(2)\n";
    std::cout << "===================================================\n\n";
    
    Matrix A({{1, 1, 0, 1},
              {0, 1, 1, 0},
              {1, 0, 1, 1},
              {1, 1, 1, 0}}, 2, 1);
    
    std::cout << "Исходная матрица:\n" << A << "\n\n";
    std::cout << "Цель: привести матрицу к ступенчатому виду\n";
    std::cout << "----------------------------------------------\n\n";
    
    auto result = A.forwardGauss(true);
    
    std::cout << "\nШаги преобразования:\n";
    for (size_t i = 0; i < result.steps.size(); ++i) {
        std::cout << (i + 1) << ". " << result.steps[i] << "\n";
    }
    
    std::cout << "\nРезультат:\n" << result.matrix << "\n\n";
    
    // Пример 2: Полное гауссово исключение (RREF)
    std::cout << "===================================================\n";
    std::cout << "ПРИМЕР 2: Приведение к систематическому виду (RREF)\n";
    std::cout << "===================================================\n\n";
    
    Matrix B({{1, 2, 1},
              {2, 1, 2},
              {1, 1, 0}}, 3, 1);
    
    std::cout << "Исходная матрица (над GF(3)):\n" << B << "\n\n";
    std::cout << "Цель: привести к приведённому ступенчатому виду\n";
    std::cout << "----------------------------------------------\n\n";
    
    result = B.reducedRowEchelonForm(true);
    
    std::cout << "\nШаги преобразования:\n";
    for (size_t i = 0; i < result.steps.size(); ++i) {
        std::cout << (i + 1) << ". " << result.steps[i] << "\n";
    }
    
    std::cout << "\nРезультат:\n" << result.matrix << "\n\n";
    
    // Пример 3: Нахождение обратной матрицы
    std::cout << "===================================================\n";
    std::cout << "ПРИМЕР 3: Нахождение обратной матрицы\n";
    std::cout << "===================================================\n\n";
    
    Matrix C({{1, 0, 1},
              {0, 1, 1},
              {1, 1, 1}}, 2, 1);
    
    std::cout << "Исходная матрица:\n" << C << "\n\n";
    std::cout << "Цель: найти обратную матрицу методом Гаусса-Жордана\n";
    std::cout << "Метод: создаём расширенную матрицу [A | I] и приводим к [I | A^(-1)]\n";
    std::cout << "----------------------------------------------\n\n";
    
    auto invC = C.inverse(true);
    
    if (invC) {
        std::cout << "\n\nИтоговая обратная матрица:\n" << *invC << "\n\n";
        
        // Проверка
        Matrix check = C * (*invC);
        std::cout << "Проверка: A * A^(-1) = I\n";
        std::cout << "Результат умножения:\n" << check << "\n\n";
    }
    
    // Пример 4: Решение системы уравнений
    std::cout << "===================================================\n";
    std::cout << "ПРИМЕР 4: Решение системы линейных уравнений\n";
    std::cout << "===================================================\n\n";
    
    std::cout << "Система уравнений над GF(2):\n";
    std::cout << "  x + y     = 1\n";
    std::cout << "      y + z = 0\n";
    std::cout << "  x     + z = 1\n\n";
    
    Matrix sys({{1, 1, 0, 1},
                {0, 1, 1, 0},
                {1, 0, 1, 1}}, 2, 1);
    
    std::cout << "Расширенная матрица [A | b]:\n" << sys << "\n\n";
    std::cout << "Цель: привести к виду [I | x] для получения решения\n";
    std::cout << "----------------------------------------------\n\n";
    
    result = sys.reducedRowEchelonForm(true);
    
    std::cout << "\nШаги преобразования:\n";
    for (size_t i = 0; i < result.steps.size(); ++i) {
        std::cout << (i + 1) << ". " << result.steps[i] << "\n";
    }
    
    std::cout << "\nРезультат:\n" << result.matrix << "\n\n";
    
    std::cout << "Решение системы:\n";
    std::cout << "  x = " << result.matrix(0, 3) << "\n";
    std::cout << "  y = " << result.matrix(1, 3) << "\n";
    std::cout << "  z = " << result.matrix(2, 3) << "\n\n";
    
    // Пример 5: Вырожденная матрица
    std::cout << "===================================================\n";
    std::cout << "ПРИМЕР 5: Попытка обратить вырожденную матрицу\n";
    std::cout << "===================================================\n\n";
    
    Matrix D({{1, 0, 1},
              {0, 1, 1},
              {1, 1, 0}}, 2, 1);
    
    std::cout << "Исходная матрица:\n" << D << "\n\n";
    std::cout << "Попытка найти обратную матрицу...\n";
    std::cout << "----------------------------------------------\n\n";
    
    auto invD = D.inverse(true);
    
    if (!invD) {
        std::cout << "\nКак видно, матрица необратима, так как её ранг меньше размера.\n";
        std::cout << "Ранг матрицы: " << D.rank() << "\n";
        std::cout << "Размер матрицы: " << D.rows() << "x" << D.cols() << "\n\n";
    }
    
    return 0;
}
